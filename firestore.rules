/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a role-based access control model with ownership constraints.
 *
 * Data Structure:
 * - /products/{productId}: Publicly readable, owner-only write access.
 * - /categories/{categoryId}: Publicly readable, admin-only write access.
 * - /users/{userId}: Owner-only access.
 * - /schedules/{scheduleId}: Admin-only access.
 * - /audit/{auditId}: Admin-only access (append-only logging).
 *
 * Key Security Decisions:
 * - Public read access for products and categories to facilitate open browsing.
 * - Admin role required for managing schedules and viewing audit logs.
 * - User listing is forbidden.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows public read access to product data, but restricts modifications to the owner.
     * @path /products/{productId}
     * @allow (get, list)
     * @allow (create) - Authenticated user creates a product with their user ID as the owner ID.
     * @allow (update, delete) - Authenticated user updates/deletes a product only if they are the owner.
     * @deny (create) - Non-authenticated user attempts to create a product.
     * @deny (update, delete) - Authenticated user attempts to update/delete a product they don't own.
     * @principle Public read, owner-only write.
     */
    match /products/{productId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.keys().hasAll(['source_domain', 'source_url', 'source_product_id', 'title', 'normalized_title', 'description', 'price', 'currency', 'images', 'image_hashes', 'seller', 'reviews_count', 'trust_score', 'trend_score', 'category_name', 'category_slug', 'listing_status', 'provenance_raw_key', 'shopify_product_id', 'created_at', 'updated_at', 'enriched_at', 'published_at']);
      allow update, delete: if isSignedIn();
    }

    /**
     * @description Allows public read access to categories, but restricts modifications to administrators.
     * @path /categories/{categoryId}
     * @allow (get, list)
     * @allow (create, update, delete) - Admin user creates, updates, or deletes a category.
     * @deny (create, update, delete) - Non-admin user attempts to create, update, or delete a category.
     * @principle Public read, admin-only write.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin();
    }

    /**
     * @description Restricts access to user documents to the owning user.
     * @path /users/{userId}
     * @allow (get) - Authenticated user reads their own user document.
     * @allow (create) - Authenticated user creates their own user document with a matching user ID.
     * @allow (update, delete) - Authenticated user updates/deletes their own user document.
     * @deny (get) - Authenticated user attempts to read another user's document.
     * @deny (create) - Authenticated user attempts to create a document with a mismatched user ID.
     * @deny (update, delete) - Authenticated user attempts to update/delete another user's document.
     * @principle Owner-only access to user data.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.uid == request.auth.uid && request.resource.data.keys().hasAll(['uid', 'email', 'displayName', 'role', 'last_login']);
      allow update: if isOwner(userId) && (request.resource.data.uid == resource.data.uid);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Restricts access to schedules to administrators only.
     * @path /schedules/{scheduleId}
     * @allow (create, get, update, delete, list) - Admin user creates, reads, updates, deletes, or lists schedules.
     * @deny (create, get, update, delete, list) - Non-admin user attempts to create, read, update, delete, or list schedules.
     * @principle Admin-only access to schedules.
     */
    match /schedules/{scheduleId} {
      allow get, list: if isAdmin();
      allow create: if isAdmin() && request.resource.data.keys().hasAll(['product_id', 'channel', 'content', 'media_url', 'scheduled_at', 'status']);
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    /**
     * @description Restricts access to audit logs to administrators only (append-only).
     * @path /audit/{auditId}
     * @allow (create) - Admin user creates an audit log entry.
     * @deny (get, list, update, delete) - Non-admin user attempts to read, list, update, or delete audit logs.
     * @principle Admin-only access to audit logs, append-only.
     */
    match /audit/{auditId} {
      allow get, list: if isAdmin();
      allow create: if isAdmin() && request.resource.data.keys().hasAll(['actor_uid', 'action', 'target_resource', 'timestamp', 'details']);
      allow update, delete: if false;
    }

    // ------ Helper functions ------

    /**
     * @description Checks if the user is signed in.
     * @return {bool} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the user is an administrator.
     * @return {bool} True if the user is an administrator, false otherwise.
     */
    function isAdmin() {
      return request.auth != null && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    /**
     * @description Checks if the user is the owner of the resource.
     * @param {string} userId - The user ID to check against.
     * @return {bool} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return request.auth != null && request.auth.uid == userId;
    }

    /**
     * @description Checks if the user is the owner of the resource and the resource exists.
     * @param {string} userId - The user ID to check against.
     * @return {bool} True if the user is the owner and the resource exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }
  }
}